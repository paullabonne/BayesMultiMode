---
title: "testing the estimation of continuous mixtures using stan"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# library(sn)
library(BayesMultiMode)
# install.packages("pckgstan", repos = NULL, type = "source", dependencies = TRUE)
# install.packages("rstan", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
```

# Data

## Galaxy data
```{r}
y = multimode::galaxy/1000

plot(density(y), type="l")
```

## Pen world data
```{r}
library(dplyr)
library(pwt10)

df_pwt_60 = pwt10.0 %>%
  select(year,country,rgdpe) %>%
  filter(year %in% rep(1960:1969, 1)) %>%
  group_by(country) %>%
  summarise(rgdpe = as.numeric(mean(rgdpe, na.rm=T)/1000))

df_pwt_70 = pwt10::pwt10.0 %>%
  select(year,country,rgdpe) %>%
  filter(year %in% rep(1970:1979,1)) %>%
  group_by(country) %>%
  summarise(rgdpe = as.numeric(mean(rgdpe, na.rm=T)/1000))

df_pwt_80 = pwt10::pwt10.0 %>%
  select(year,country,rgdpe) %>%
  filter(year %in% rep(1980:1989,1)) %>%
  group_by(country) %>%
  summarise(rgdpe = as.numeric(mean(rgdpe, na.rm=T)/1000))

df_pwt_90 = pwt10::pwt10.0 %>%
  select(year,country,rgdpe) %>%
  filter(year %in% rep(1990:1999,1)) %>%
  group_by(country) %>%
  summarise(rgdpe = as.numeric(mean(rgdpe, na.rm=T)/1000))

df_pwt_00 = pwt10::pwt10.0 %>%
  select(year,country,rgdpe) %>%
  filter(year %in% rep(2000:2009,1)) %>%
  group_by(country) %>%
  summarise(rgdpe = as.numeric(mean(rgdpe, na.rm=T)/1000))

df_pwt_10 = pwt10::pwt10.0 %>%
  select(year,country,rgdpe) %>%
  filter(year %in% rep(2010:2019,1)) %>%
  group_by(country) %>%
  summarise(rgdpe = as.numeric(mean(rgdpe, na.rm=T)/1000))

y = unlist(df_pwt_10$rgdpe[!is.na(df_pwt_10$rgdpe)])/1000
y = y
hist(y, breaks = 200)
```

## Normal draws
```{r, eval = FALSE}
mu = c(0.5,2,4)
sigma = c(0.3,0.4,0.2)
p = c(0.3,0.5,0.2)
nb_draws = 200

y = c(rnorm(nb_draws*p[1], mu[1], sigma[1]),
      rnorm(nb_draws*p[2], mu[2], sigma[2]),
      rnorm(nb_draws*p[3], mu[3], sigma[3]))

hist(y,main = "Simulated data", breaks=100)
```

## Student t draws
```{r}
N = 100
y = c(rst(0.3*N, xi = 2, omega = 0.5, nu = 2),
      rst(0.7*N, xi = 10, omega = 1, nu = Inf))

hist(y, breaks = 100)
plot(density(y), type="l")
```

## Skew normal draws
The skew normal density of Azzalini takes the form 
$$f(x, \mu, \sigma, \alpha) = \frac{2}{\sigma}\phi(\frac{x-\mu}{\sigma})\Phi(\alpha \frac{x-\mu}{\sigma}),$$ 
where $\sigma \in R^+$ is a scale parameter, $\mu \in R$ a location parameter $\alpha \in R$ the shape or asymmetry parameter. The functions $\phi(.)$ and $\Phi(.)$ are the density and cumulative functions of the normal distribution.
```{r}
N = 200
y = c(rsn(0.6*N, 0, 1, 20),rsn(0.4*N, 3, 0.5, 0))

hist(y, breaks = 100)
```

## Skew t draws
```{r}
N = 200
y = c(rst(0.7*N, xi = 0, omega = 1, alpha = 20, nu= 2),
      rst(0.3*N, xi = 5, omega = 0.5, alpha = 0, nu= Inf))

hist(y, breaks = 100)
```

# Bayesian estimation
```{r, message =FALSE, warning=FALSE}
K = 4
dist = "skew_normal"

fit = bayes_estimation(y, K = K, dist, chains = 1, nb_iter = 2000)
mixture_plot(y, K, fit, dist, max_size = 500)

# mcmc_output = rstan::extract(fit, permuted = FALSE)[,1,]
# round(apply(mcmc_output,2,mean),2)

# print(fit, pars = colnames(as.matrix(fit)))
# rstan::traceplot(fit, pars = colnames(as.matrix(fit)))
# rstan::traceplot(fit, inc_warmup = TRUE, pars = colnames(as.matrix(fit)))
# plot(fit)

# posterior <- as.matrix(fit)
# plot_title <- ggtitle("Posterior distributions",
#                       "with medians and 80% intervals")
# mcmc_areas(posterior,
#            pars = colnames(posterior)[grep("theta", colnames(posterior))],
#            prob = 0.8) + plot_title

# traceplot(fit, pars = colnames(posterior)[1:K], inc_warmup = TRUE)
# traceplot(fit, pars = colnames(posterior)[(K+1):(2*K)], inc_warmup = TRUE)
```

# Mode estimation
```{r}
# options(error = recover)
## This function overcomes the problem arising from comparing floating points (0.1==0.1 can be false for instance, see https://stackoverflow.com/questions/9508518/why-are-these-numbers-not-equal/9508558#9508558)
`%.in%` = function(a, b, eps = sqrt(.Machine$double.eps)) {
  output = rep(F,length(b))
  for (x in a){
    output <- (abs(b-x) <= eps) | output
  }
  output
}

## the other option would be to generate observations for each draw using the estimated mixture and round the data to an arbitrary decimal. 
mcmc_output = as_draws_matrix(fit)
mcmc_output = cbind(mcmc_output, "min_y" = min(y), "max_y" = max(y))

if (dist == "gaussian") {
  ### fixed point
  modes = t(apply(mcmc_output[,], 1, fixed_point, tol_x = sd(y)/10)) 
} 

if (dist %in% c("student", "skew_normal")) {
  ### MEM 
  # MEM(pars)
  
  modes = t(apply(mcmc_output, 1, MEM, dist = dist, tol_x = sd(y)/10, show_plot=F))
}


### inference

### Number of modes and their associated probs
# Number of modes 
n_modes = apply(!is.na(modes),1,sum) # number of modes in each MCMC draw

# testing unimodality
if(any(n_modes==1)){
  Post_prob_number_modes_equal_one = length(n_modes[n_modes==1])/nrow(modes)
} else {
  Post_prob_number_modes_equal_one = 0
}

# Test for number of modes : number of modes and their posterior probability
possible_nb_modes = unique(n_modes)
post_prob_nb_modes = rep(NA,length(possible_nb_modes))
for (i in 1:length(possible_nb_modes)){
  post_prob_nb_modes[i] = length(n_modes[n_modes==possible_nb_modes[i]])/nrow(modes)
}
table_nb_modes = rbind(possible_nb_modes,post_prob_nb_modes)

df_g1 = dplyr::as_tibble(t(table_nb_modes))
ggplot(data=df_g1, aes(x=possible_nb_modes, y=post_prob_nb_modes)) +
  # theme_gg +
  scale_x_continuous(breaks=possible_nb_modes) +
  ggtitle("Number of modes") +
  ylim(0, 1) +
  xlab("") + ylab("Posterior probability") +
  geom_bar(stat="identity")

### Posterior probability of being a mode for each location
rd = 0 # rouding decimal
m_range = seq(from = min(round(y,rd)), to = max(round(y,rd)), by = 1/(10^rd)) # range of potential values for the modes
modes_disc = round(modes, digits = rd)

matrix_modes = matrix(0, nrow = nrow(modes), ncol = length(m_range))
for (i in 1:nrow(matrix_modes)) {
  matrix_modes[i, modes_disc[i, ][!is.na(modes_disc[i, ])] %.in% m_range] = 1
}

sum_modes = apply(matrix_modes,2,sum)
probs_modes = sum_modes/nrow(modes)
probs_modes = probs_modes[probs_modes>0]
location_at_modes = m_range[sum_modes>0]

table_location = rbind(location_at_modes, probs_modes)

df_g2 = dplyr::as_tibble(t(table_location))
ggplot(data=df_g2, aes(x=location_at_modes, y=probs_modes)) +
  # theme_gg + 
  ggtitle("Mode locations") +
  ylim(0, max(probs_modes)) +
  xlab("") + ylab("Posterior probability") +
  geom_bar(stat="identity")
```

## illustration using ten iterations
```{r}
modes = t(apply(mcmc_output_post[1:10,], 1, MEM, plots=T))
```

